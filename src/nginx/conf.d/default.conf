# 1M creates 1Mb zone. Somewhat overkill for our usecase but it's fine
js_shared_dict_zone zone=apk:1M timeout=60s;

server {
    js_path "/etc/nginx/njs/";
    js_import subrequest.js;

    js_set $getPublicKey subrequest.getPublicKey;

    listen 80; # Assigns the port that the proxy will listen on (http://localhost:port)
    server_name localhost; # Assigns the name of the server (localhost in this case, it could be anything though if we configured the DNS)

    # This is the root location
    # This routes all requests that don't have a valid endpoint specified to the webserver
    location / {
        resolver 127.0.0.11 valid=10s;
        set $upstream_webserver webserver:3000;
        proxy_pass http://$upstream_webserver;
    }

    # TODO: Change all instances of 'login' to 'signin' for consistence
    location /login {
        # Here we rewrite the url '/login' to '/account/login' and then NGINX searches for a different location that matches this
        rewrite ^/login$ /account/login;
        try_files false @account;
    }

    location /register {
        rewrite ^/register$ /account/register;
        try_files false @account;
    }

    location /account {
        try_files false @account;
    }

    location /webserver/public_keys {
        internal;
        resolver 127.0.0.11 valid=10s;
        set $upstream_webserver webserver:3000;
        proxy_pass http://$upstream_webserver;
    }

    location = /public_key {
        # Internal directive included so that only internal redirects can access this location
        # This is a public key so it doesn't really matter if it's internal but no external services need to access this
        internal;
        try_files false @account;
    }

    # TODO: Combine with @try_account since this is redundant
    location @account {
        resolver 127.0.0.11 valid=10s;
        set $upstream_account_server account_server:3000;
        proxy_pass http://$upstream_account_server$uri;
    }

    # TODO: Finish implementing and finish authorization
    location /orders {
        auth_request /auth;

        resolver 127.0.0.11 valid=10s;
        set $upstream_order_server order_server:3000;
        proxy_pass http://$upstream_order_server;
    }

    # TODO: Add as parameter for auth_request
    location = /auth {
        resolver 127.0.0.11 valid=10s;
        set $upstream_auth_server auth_server:3000;
        proxy_pass http://$upstream_auth_server;
        proxy_pass_request_body off;
        proxy_set_header Content-Length "";
        proxy_set_header X-Original-URI $request_uri;
    }

    # This allows the client to get static files (css, js, html, etc.) from the proxy (so that the proxy doesn't have to make a request to each service to get the files)
    location /static/ {
        try_files $uri @try_webserver;
    }

    location @try_webserver {
        resolver 127.0.0.11 valid=10s;
        set $upstream_webserver webserver:3000;
        proxy_pass http://$upstream_webserver$uri;
        # This allows us to chain multiple try locations so that any service with static files can be tried
        proxy_intercept_errors on;
        recursive_error_pages on;
        error_page 404 = @try_account;
    }

    location @try_account {
        resolver 127.0.0.11 valid=10s;
        set $upstream_account_server account_server:3000;
        proxy_pass http://$upstream_account_server$uri;
    }

    # Automatically call this/these function periodically
    location @periodics {
        resolver 127.0.0.11;
        js_periodic subrequest.setPublicKey interval=5s; # Change this to send public key to webserver more/less frequently
    }
}